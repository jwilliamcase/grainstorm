{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww17520\viewh21840\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs26 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 <Plan>\
Below is a high-level technical implementation plan for GRAINSTORM, aligned with the PRD requirements. \
It focuses on how the code should be organized and the architectural decisions needed for each major milestone.\
\
-------------------------------------------------------------------------------\
1. PROJECT STRUCTURE & FILE ORGANIZATION\
-------------------------------------------------------------------------------\
\'95 Maintain the current folder layout in `grainstorm/`:\
  - index.html      \'96 Main entry point, HTML structure\
  - styles.css      \'96 Core CSS or rename to style.css for consistency\
  - main.js         \'96 High-level controller and UI logic\
  - grainstormProcessor.js  \'96 AudioWorkletProcessor for granular DSP\
  - Possibly add files/folders as features expand:\
    \uc0\u9656  dsp/          \'96 If more complex DSP is extracted into multiple AudioWorklets\
    \uc0\u9656  ui/           \'96 Shared UI widgets or helper classes (knobs, XY pads, etc.)\
    \uc0\u9656  utils/        \'96 Common utility functions (file loading, preset management, etc.)\
\
\'95 Use at least one \'93AudioWorklet\'94 JavaScript file (grainstormProcessor.js) for the core DSP. \
  If you expand with multi-band or specialized features, you may add more AudioWorklet files \
  or keep them in a single class with band-specific branches.\
\
-------------------------------------------------------------------------------\
2. AUDIO INITIALIZATION & BASIC PLAYBACK (PHASE 1)\
-------------------------------------------------------------------------------\
Goal: Establish an AudioContext, register the AudioWorklet module, confirm basic sample playback.\
\
(1) **AudioContext Setup** \
   - In `main.js`, create or resume an AudioContext upon user gesture (especially on iOS):\
     ```js\
     const audioContext = new AudioContext();\
     // Possibly wait for a user click to call audioContext.resume().\
     ```\
   - Register the Worklet module:\
     ```js\
     audioContext.audioWorklet.addModule('grainstormProcessor.js')\
       .then(() => \{ \
         // Instantiate nodes once module is loaded \
       \});\
     ```\
\
(2) **Load Default Sample**\
   - Provide a function to load a default WAV/AIFF from your local assets:\
     ```js\
     async function loadDefaultSample() \{\
       const response = await fetch('assets/default.wav');\
       const arrayBuffer = await response.arrayBuffer();\
       return await audioContext.decodeAudioData(arrayBuffer);\
     \}\
     ```\
   - Store the decoded AudioBuffer for looping or passing to the granular engine.\
\
(3) **Create a Simple Audio Graph**\
   - Create an `AudioWorkletNode`, connect it to `audioContext.destination`.\
   - Pass the AudioBuffer to the node\'92s parameters or use a SharedArrayBuffer approach \
     if you need large amounts of read access in the processor.\
\
-------------------------------------------------------------------------------\
3. SIMPLE GRANULAR ENGINE (PHASE 2)\
-------------------------------------------------------------------------------\
Goal: Implement a minimal granular processor inside `grainstormProcessor.js` with a few key parameters.\
\
(1) **Define AudioWorkletProcessor**\
   - Inside `grainstormProcessor.js`, export a class that extends `AudioWorkletProcessor`.\
   - Add a static `parameterDescriptors` array to expose user-adjustable parameters \
     (e.g. grainSize, pitch, density):\
     ```js\
     class GrainstormProcessor extends AudioWorkletProcessor \{\
       static get parameterDescriptors() \{\
         return [\
           \{ name: 'grainSize', defaultValue: 0.1, minValue: 0.01, maxValue: 1.0 \},\
           \{ name: 'pitch', defaultValue: 1.0, minValue: 0.5, maxValue: 2.0 \},\
           // etc.\
         ];\
       \}\
       constructor(options) \{ ... \}\
       process(inputs, outputs, parameters) \{ ... \}\
     \}\
     ```\
   - Register it:\
     ```js\
     registerProcessor('grainstorm-processor', GrainstormProcessor);\
     ```\
\
(2) **Parameter Control in main.js**\
   - Instantiate the node with optional `parameterData`:\
     ```js\
     const grainstormNode = new AudioWorkletNode(audioContext, 'grainstorm-processor', \{\
       parameterData: \{\
         grainSize: 0.1,\
         pitch: 1.0\
       \}\
     \});\
     ```\
   - For real-time user control, connect UI sliders to node parameters:\
     ```js\
     const grainSizeParam = grainstormNode.parameters.get('grainSize');\
     // On slider input:\
     grainSizeParam.value = sliderValue; \
     ```\
\
(3) **Schedule Grains (Minimal Approach)**\
   - In `process(inputs, outputs, parameters)`, read from an AudioBuffer or maintain a pointer \
     for the current read position. Generate micro-buffers or short windows if possible.\
   - This is a simplified approach. Later expansions will handle multi-band, window shapes, etc.\
\
-------------------------------------------------------------------------------\
4. MULTI-BAND & ADVANCED PARAMETERS (PHASE 3)\
-------------------------------------------------------------------------------\
Goal: Implement a 3-band crossover and run separate granular processes per band. \
Add additional parameters like overlap, window type, random scanning, reverse probability, etc.\
\
(1) **Three-Band Crossover**\
   - Decide if you want the crossover filters in the main.js node graph or inside the \
     AudioWorkletProcessor. \
   - If in main.js:\
     1. Create three BiquadFilterNodes or IIRFilterNodes for low/mid/high separation.\
     2. Duplicate three separate AudioWorkletNodes (one for each band).\
     3. Connect each filter to a separate node, then sum outputs into a gain node \uc0\u8594  audioContext.destination.\
   - Alternatively, do it in the Worklet if you prefer. Each approach has different trade-offs \
     (e.g. controlling filter cutoff/steepness from the processor vs. from main.js).\
\
(2) **Band-Specific Parameters**\
   - Each band might have different grainSize, pitch, etc. If using separate AudioWorkletNodes, \
     each can hold its own parameter set. If using one node, plan an internal structure for band arrays:\
     ```js\
     parameterDescriptors: [\
       \{ name: 'grainSizeLow', ... \},\
       \{ name: 'grainSizeMid', ... \},\
       \{ name: 'grainSizeHigh', ... \},\
       ...\
     ];\
     ```\
   - If toggling multi-band off, either remove or bypass the band-split nodes in main.js, or \
     handle it internally in the processor code.\
\
(3) **Window Type & Reverse Probability**\
   - Expand your parameterDescriptors with enumerations or use integer-coded parameters \
     for window shapes, e.g. 0=Hann, 1=Hamming, 2=Triangle, 3=Gaussian.\
   - For reverse probability, add a parameter that toggles reading the sample in reverse \
     for a certain fraction of grains.\
\
(4) **Random / LFO / Sequencer Position**\
   - Expose a parameter controlling positionMode: 0=Linear, 1=Random, 2=LFO, 3=4-Step, etc.\
   - For random scanning, pick a random read offset each time a grain is scheduled.\
   - For LFO-based scanning, keep an internal LFO phase that increments each block, \
     adjusting the read position.\
   - For a 4-step sequencer, define an array of positions to jump to (expose them as parameters or \
     pass them in as an array from main.js).\
\
-------------------------------------------------------------------------------\
5. MUSICAL TYPING & NOTES (PHASE 3/4)\
-------------------------------------------------------------------------------\
Goal: Let users press A-S-D-F-G-H-J-K-L (and black key equivalents) to trigger or pitch grains.\
\
(1) **Keydown Events in main.js**\
   - Add an event listener on `window` or a dedicated text element:\
     ```js\
     window.addEventListener('keydown', (event) => \{\
       handleKeyPress(event.key);\
     \});\
     ```\
   - Map each letter to a note value (e.g. MIDI note). \
     - White keys: A=60 (C4), S=62 (D4), etc.\
     - Black keys: W=61 (C#4), E=63 (D#4), etc.\
     - Z / X shifts octave \'b112 semitones.\
\
(2) **Trigger vs. Continuous Pitch**\
   - If the engine triggers a new grain on each note, pass a parameter or message \
     (via `port.postMessage`) to the AudioWorklet to schedule a new grain.\
   - If it\'92s continuous pitch shift, simply set the pitch parameter to the appropriate ratio:\
     ```js\
     pitchParam.value = Math.pow(2, (midiNote - 60) / 12);\
     ```\
   - Provide a UI switch for \'93Trigger\'94 vs. \'93Continuous.\'94\
\
(3) **Data Handling in the Processor**\
   - For real-time triggered grains, your processor will read a message (via `port.onmessage`) \
     that signals which note was pressed, possibly scheduling a new grain at that moment.\
\
-------------------------------------------------------------------------------\
6. A/B COMPARE & BYPASS (PHASE 4)\
-------------------------------------------------------------------------------\
Goal: Let the user toggle between two parameter sets or bypass the effect entirely.\
\
(1) **A/B Compare**\
   - Maintain two sets of parameters in main.js. When user clicks \'93Swap,\'94 \
     reassign the node parameters from setA to setB or vice versa.\
   - Alternatively, store them in custom JS objects and apply them to the node.\
\
(2) **Bypass**\
   - In main.js, you can simply connect or disconnect the AudioWorkletNode from the graph. \
   - Or incorporate a bypass parameter that makes the processor output unmodified input. \
     - E.g. route the input sample directly to output if bypassParam===1.\
\
-------------------------------------------------------------------------------\
7. PRESETS & SETTINGS MANAGEMENT (PHASE 5)\
-------------------------------------------------------------------------------\
Goal: Allow saving/loading param sets and possibly the associated sample reference.\
\
(1) **Preset Data Structure**\
   - A typical structure:\
     ```js\
     const preset = \{\
       name: 'Dreamy Reverse',\
       parameters: \{\
         grainSize: 0.3,\
         pitch: 1.2,\
         windowType: 2,\
         reverseProb: 0.5,\
         ...\
       \},\
       sampleUrl: 'assets/mySample.wav'\
     \};\
     ```\
   - Store in localStorage or an IndexedDB for user presets.\
\
(2) **Save/Load Logic**\
   - Provide UI to gather current parameter values from the node.\
   - Store them under a user-chosen preset name in localStorage.\
   - A \'93Load Preset\'94 dropdown can retrieve that preset, apply the parameters, \
     and optionally re-load the sample if the `sampleUrl` is specified.\
\
-------------------------------------------------------------------------------\
8. SATURATING LIMITER / OUTPUT FILTER (PHASE 5)\
-------------------------------------------------------------------------------\
Goal: Add a final stage that prevents clipping and can apply saturation or a simple filter.\
\
(1) **Implementation Options**\
   - JavaScript (main.js) side:\
     - Insert a final BiquadFilterNode or waveshaper for saturation. \
   - AudioWorklet side:\
     - Implement a saturating algorithm in the DSP code (e.g., soft clip approach).\
   - Provide a parameter \'93drive\'94 or \'93filterCutoff\'94 for user control.\
\
-------------------------------------------------------------------------------\
9. CRITICAL ARCHITECTURAL DECISIONS & IMPACT\
-------------------------------------------------------------------------------\
(1) **Storing & Accessing Audio Buffers**\
   - For large files, consider a SharedArrayBuffer approach or keep it in main.js and \
     pass small chunks to the processor. Evaluate performance and memory constraints.\
\
(2) **Single vs. Multiple AudioWorkletNodes**\
   - A single node with multiple internal band-splits can be simpler to coordinate but \
     more complex to maintain. Multiple nodes are easier to debug but can add overhead.\
\
(3) **Parameter Handling vs. PostMessages**\
   - For real-time parameters that can be expressed as numbers, use the `parameters` map. \
     For more complex controls (like sequencer positions or note triggers), consider `port.postMessage`.\
\
(4) **Mobile Performance Constraints**\
   - Consider limiting max overlap or applying a usage cap if device CPU is taxed. \
   - Possibly degrade gracefully by reducing density or disabling multi-band on underpowered devices.\
\
(5) **UI Strategy**\
   - For small screens, ensure horizontal scroll or an adaptive layout for controls. \
   - Use a well-organized approach to avoid clutter (tabs, collapsible sections, or multi-page views).\
\
-------------------------------------------------------------------------------\
10. NEXT STEPS & POTENTIAL EXTENSIONS\
-------------------------------------------------------------------------------\
\'95 Once the core architecture is stable:\
  - Add advanced features like 4-step sequencer in a separate UI panel or advanced mode tab.\
  - Integrate visual feedback (waveform display, real-time amplitude/frequency scope).\
  - Explore TypeScript for maintainability, adding a build step for bundling.\
  - Add more creative DSP (e.g., spectral gating, convolution reverb, advanced LFO shapes).\
\
-------------------------------------------------------------------------------\
SUMMARY\
-------------------------------------------------------------------------------\
This plan outlines how to break down GRAINSTORM\'92s development into clear phases aligned with the PRD:\
1. Basic audio engine setup and default sample playback\
2. Simple granular processor with parameter control\
3. Multi-band approach and advanced granular parameters (reverse, randomization, envelopes, etc.)\
4. Musical typing, UI design, and advanced toggles (A/B compare, bypass)\
5. Preset system, saturating limiter, final polish\
6. Optional expansions (native ports, spectral or FFT-based modes)\
\
Each major feature requires:\
- Updates in `main.js` to manage parameters/UI interactions\
- Updates in `grainstormProcessor.js` to implement DSP logic\
- Potential additions to `index.html` or new UI files for layout and controls\
- Possibly new modules or supporting files (e.g., `utils/presetManager.js` for presets, etc.)\
\
Following these steps will ensure a robust, extensible architecture that meets the PRD\'92s goals and is straightforward to refine or expand over time.\
</Plan>\
}